# ADR-004: Invite-Based Authentication

## Status

Accepted

## Date

2024-01-15

## Context

Building on the trusted peer model (ADR-002), we need a concrete authentication mechanism that:
- Works in a decentralized environment
- Is user-friendly (no complex PKI management)
- Prevents unauthorized access
- Supports both human-to-human and automated invitation flows
- Allows for invite revocation and expiration

Traditional authentication approaches:
- **Username/Password**: Requires centralized authentication server
- **OAuth/OIDC**: Depends on external identity providers
- **TLS Client Certificates**: Complex key management, difficult UX
- **Pre-shared Keys**: No granularity, difficult to revoke

## Decision

We implement **cryptographic invite codes** that authenticate new peers joining the network.

### Invite Structure

An invite is a signed data structure containing:

```go
type Invite struct {
    // Core fields
    InviterI2P        string    `json:"inviter"`         // Inviter's I2P destination
    InviteeWGKey      string    `json:"invitee_wg_key"`  // Pre-allocated WireGuard public key
    TrustLevel        string    `json:"trust_level"`     // "admin" or "member"
    
    // Metadata
    CreatedAt         time.Time `json:"created_at"`
    ExpiresAt         time.Time `json:"expires_at,omitempty"`  // Optional expiration
    Nonce             []byte    `json:"nonce"`           // 16-byte random nonce
    
    // Optional fields
    Label             string    `json:"label,omitempty"` // Human-readable label (e.g., "Alice's laptop")
    MaxUses           int       `json:"max_uses"`        // 0 = unlimited, >0 = limited uses
    
    // Cryptographic binding
    Signature         []byte    `json:"signature"`       // Ed25519 signature over all fields
}
```

### Authentication Flow

1. **Invite Generation** (by existing network member):
   ```
   Admin/Member Node                    New Peer
   -----------------                    --------
   1. Generate invite:
      - Create new WireGuard keypair
      - Sign invite with I2P private key
      - Encode as base64 or QR code
   
   2. Share invite out-of-band
      (Signal, email, QR code, etc.)
   ```

2. **Invite Redemption** (by new peer):
   ```
   New Peer                             Receiving Node
   --------                             --------------
   1. Connect to any peer via I2P
   
   2. Send AuthRequest:                 →
      - Present invite code
      - Prove possession of WG private key
        (sign challenge with WG key)
      - Provide I2P destination
   
   3.                                   ← Validate:
                                          - Check signature against known identities
                                          - Verify invite not expired/revoked
                                          - Verify WG key challenge
                                          - Check max uses not exceeded
   
   4.                                   ← If valid:
                                          - Add to local identity store
                                          - Add WireGuard peer
                                          - Gossip new identity to mesh
                                          - Send AuthSuccess
   
   5. Receive AuthSuccess              ←
      Begin normal mesh participation
   ```

3. **Trust Propagation** (via gossip):
   ```
   Receiving Node                       Other Mesh Nodes
   --------------                       ----------------
   1. Gossip IdentitySync:              →
      - New identity info
      - Invitation lineage
      - Trust level
   
   2.                                   ← Other nodes validate:
                                          - Inviter is trusted
                                          - Signature valid
                                          - Add to local identity stores
   ```

### Invite Code Format

Human-shareable format:
```
i2plan://invite/v1?d=<base64-data>&s=<base64-signature>
```

Example:
```
i2plan://invite/v1?d=eyJpbnZpdGVyIjoianNjN...&s=mKE3Vf8xQ2...
```

Can be rendered as QR code for mobile/GUI clients.

## Consequences

### Positive

- **User-Friendly**: Share invite codes like sharing WiFi passwords
- **Secure**: Cryptographically bound to inviter's identity
- **Decentralized**: No central authentication service
- **Flexible**: Support for expiration, usage limits, labels
- **Accountable**: Invitation lineage creates social accountability
- **Revocable**: Invites can be explicitly revoked in identity store

### Negative

- **Out-of-Band Sharing**: Requires secure channel to share invite (Signal, in-person, etc.)
- **Key Pre-Allocation**: WireGuard key must be generated by inviter
- **Invite Theft**: Stolen invite codes can be redeemed by attacker before legitimate user
- **No Identity Binding**: Invite doesn't verify invitee's real-world identity

### Trade-offs

- **Security vs UX**: Simple string codes traded against potential for invite theft
- **Pre-allocation vs Flexibility**: Pre-allocated keys simplify protocol but limit invitee's key management
- **Trust Transitivity**: We accept that trust is inherited from inviter (social accountability model)

## Implementation Details

### Invite Generation

```go
// In lib/identity/invite.go
func (s *Store) GenerateInvite(trustLevel TrustLevel, opts InviteOptions) (*Invite, error) {
    // 1. Generate new WireGuard keypair for invitee
    privKey, err := wgtypes.GeneratePrivateKey()
    if err != nil {
        return nil, err
    }
    
    // 2. Create invite structure
    invite := &Invite{
        InviterI2P:   s.localIdentity.I2PDestination,
        InviteeWGKey: privKey.PublicKey().String(),
        TrustLevel:   trustLevel,
        CreatedAt:    time.Now(),
        ExpiresAt:    opts.ExpiresAt,
        Nonce:        randomBytes(16),
        Label:        opts.Label,
        MaxUses:      opts.MaxUses,
    }
    
    // 3. Sign with I2P private key
    invite.Signature = s.i2pKeys.Sign(invite.SerializeForSigning())
    
    // 4. Store private key for invitee (to be retrieved after redemption)
    s.storeInviteKey(invite.Nonce, privKey)
    
    return invite, nil
}
```

### Invite Validation

```go
// In lib/identity/invite.go
func (s *Store) ValidateInvite(invite *Invite, challengeResponse []byte) error {
    // 1. Check expiration
    if !invite.ExpiresAt.IsZero() && time.Now().After(invite.ExpiresAt) {
        return ErrInviteExpired
    }
    
    // 2. Check usage limit
    uses := s.getInviteUseCount(invite.Nonce)
    if invite.MaxUses > 0 && uses >= invite.MaxUses {
        return ErrInviteExhausted
    }
    
    // 3. Verify signature against known identities
    inviterIdentity, err := s.GetIdentity(invite.InviterI2P)
    if err != nil {
        return ErrUnknownInviter
    }
    
    if !inviterIdentity.VerifySignature(invite.SerializeForSigning(), invite.Signature) {
        return ErrInvalidSignature
    }
    
    // 4. Verify invitee proves possession of WG private key
    expectedChallenge := signChallenge(invite.Nonce, invite.InviteeWGKey)
    if !bytes.Equal(challengeResponse, expectedChallenge) {
        return ErrInvalidChallenge
    }
    
    // 5. Check inviter has permission to create this trust level
    if invite.TrustLevel == TrustLevelAdmin && inviterIdentity.TrustLevel != TrustLevelAdmin {
        return ErrInsufficientPrivileges
    }
    
    return nil
}
```

### Authentication Protocol

RPC messages (see `lib/rpc/protocol.go`):

```protobuf
message AuthRequest {
    bytes invite = 1;              // Serialized Invite structure
    string i2p_destination = 2;    // Invitee's I2P destination
    bytes wg_challenge = 3;        // Signed challenge proving WG key possession
}

message AuthResponse {
    bool success = 1;
    string error_message = 2;      // If !success
    string assigned_ip = 3;        // WireGuard IP assigned to peer
    bytes mesh_state = 4;          // Initial mesh state dump
}
```

## Security Considerations

### Invite Theft

If an attacker obtains an invite code before the legitimate invitee:
- **Mitigation 1**: Short expiration times (default: 1 hour)
- **Mitigation 2**: Usage limits (default: 1 use)
- **Mitigation 3**: Out-of-band invite sharing (encrypted channels)
- **Mitigation 4**: Inviter can revoke stolen invites via banlist

### Replay Attacks

Prevent invite reuse:
- Track used nonces in identity store
- Enforce MaxUses limit
- Gossip invite redemptions to prevent double-spend across nodes

### Signature Verification

All signature operations use constant-time comparison:
```go
func (id *Identity) VerifySignature(msg, sig []byte) bool {
    return ed25519.Verify(id.PublicKey, msg, sig)
}
```

### Challenge-Response

Invitee must prove possession of WireGuard private key:
```go
func signChallenge(nonce []byte, wgPubKey string) []byte {
    // Invitee signs: BLAKE2b(nonce || wg_pub_key) with WG private key
    challenge := blake2b.Sum256(append(nonce, []byte(wgPubKey)...))
    return wg.SignWithPrivateKey(challenge[:])
}
```

This prevents an attacker who steals the invite from using it without the corresponding WireGuard private key.

## Alternatives Considered

### Password-Based Authentication

- **Pros**: Simple, familiar to users
- **Cons**: Requires password management, vulnerable to brute force, centralized verification
- **Rejected**: Doesn't align with decentralized model

### TLS Client Certificates

- **Pros**: Industry standard, strong security
- **Cons**: Complex PKI setup, poor UX, requires CA
- **Rejected**: Too complex for target users

### OAuth2/OIDC

- **Pros**: Mature, widely supported
- **Cons**: Requires external identity provider, centralized
- **Rejected**: Introduces external dependencies

### Magic Links (Email/SMS)

- **Pros**: Familiar UX
- **Cons**: Requires email/phone infrastructure, privacy concerns
- **Rejected**: Centralized, poor privacy

## User Experience

### CLI Workflow

```bash
# Generate invite (existing member)
$ i2plan invite create --trust-level member --label "Alice's laptop" --expires 1h

Generated invite code:
i2plan://invite/v1?d=eyJpbnZp...&s=mKE3V...

Share this code securely with the invitee.
WireGuard private key saved to: ~/.i2plan/invite-keys/a3f9b2c1.key

# Redeem invite (new member)
$ i2plan join i2plan://invite/v1?d=eyJpbnZp...&s=mKE3V...

Connecting to network...
✓ Invite validated
✓ Identity synchronized
✓ Joined mesh network as member

Your WireGuard IP: 10.42.1.5
```

### QR Code Workflow (GUI/Mobile)

1. Existing member generates invite, displays QR code
2. New member scans QR code with app
3. App automatically redeems invite and joins mesh
4. No manual key management required

## References

- `lib/identity/invite.go` - Invite generation and validation
- `lib/identity/store.go` - Identity and invite storage
- `lib/rpc/protocol.go` - Authentication RPC messages
- ADR-002: Trusted Peer Model - Overall trust architecture
- ADR-003: Gossip Protocol - How identities propagate
